#!perl

=head1 NAME

LCSH Changes parser 

=head2 DESCRIPTION

Parses LCSH weekly list to find cancelled and changed headings.
The input folder is a path to a dir of plaintext copy of the Weekly list(s).
Creates a temporary file to store a cleaned version of input.
The temporary file has leading and trailing spaces removed.
Outputs each file of changed headings in a tab-delimited output file as follows:
Tag number \t Old heading \t New heading
Also outputs a consolidated list of all changed headings in a separate file.

Prints to screen (during testing) problem headings (cancelled heading is not followed by a new heading)

=head2 USAGE

Save LCSH weekly list(s) to a folder/directory, in plain text.

Run the script, specifying (after launch, at the prompt) the path to the 
directory containing the lists to be cleaned.

Output directory will be a 'cleaned' directory inside of the input dir.

=head2 TO DO

Testing and scanning code for errors.
-Verify that all needed lines are copied to output.
-Verify that line break removal does not negatively impact headings themselves.

Parse the headings to look for new headings that have become old headings.

Change -- (dash) into subfield coding in preparation for global replace.
This may need to be done by the global replace program/script.

Add documentation/comments to improve readability of the code.

=head2 KNOWN PROBLEMS

Trouble with diacritics: currently the parser handles only headings with 
non-special characters (special being not in a-zA-Z0-9 and some punctuation).
While saving the file from the Web, some diacritics appear as sybols such as 
the copyright symbol.

File handling: I have not extensively tested this portion, and know that the 
Windows file paths have some trouble, though the code works for the most part.
Problems could occur if a file is dropped in to give the path, instead of a dir.

=cut

###########################
### Initialize includes ###
### and basic needs     ###
###########################
use strict;
use warnings;
use MARC::BBMARC;
use IO::File;
use File::Temp;
use File::Find;
use File::Spec;

##########################
## Time coding routines ##
## Print start time and ##
## set start variable   ##
##########################

use Time::HiRes qw(  tv_interval );
# measure elapsed time 
my $t0 = [Time::HiRes::time()];
my $startingtime = MARC::BBMARC::startstop_time();
#########################
### Start main program ##
#########################

print ("Welcome to LCSH Changes parser\n");
print <<DESCOFSCRIPT;
Parses LCSH weekly list to find cancelled and changed headings.
The input file is a plaintext copy of the Weekly list.
Creates a temporary file to store a cleaned version of input.
The temporary file has leading and trailing spaces removed.
Outputs the changed headings in a tab-delimited output file as follows:
Tag number \t Old heading \t New heading
DESCOFSCRIPT

##############################################
######### Directory manipulation #############
##############################################

#get directory name containing files to clean

print ("\nWhat is the input directory? ");
my $inputdir=<>;
chomp $inputdir;
#remove quotes from dropped in paths
$inputdir =~ s/^\"(.*)\"$/$1/;
my $root_dir = $inputdir;

#get an absolute path to the directory in case a relative path was passed, ignoring filename if one was passed
my $abs_path = File::Spec->rel2abs( $root_dir ) ;
$root_dir = $abs_path;
print "$abs_path absolute\n";
my @filestoclean;

#get list of text files in the directory to be cleaned
find( {wanted => \&process, follow=>0},
  $root_dir
);
sub process {

    my $cur_file = $File::Find::name;
      return unless (($File::Find::dir eq $root_dir) && (-f $cur_file && -T $cur_file));
push @filestoclean, $cur_file;
  }
  
#make a new directory for cleaned files
my $cleandirname;
if (($^O eq 'MacOS') && ($root_dir =~ /:$/)) {$cleandirname = 'cleaned:';}
elsif ($root_dir =~ /\\$/) {$cleandirname = 'cleaned\\';}
#elsif ($root_dir =~ /\/$/){$cleandirname = 'cleaned/';}
else {die"cleandirname could not be made\n";}
my $cleaned_dir = $root_dir.$cleandirname;

mkdir $cleaned_dir, 0744;

############################################
# Set start time for main calculation loop #
############################################
my $t1 = [Time::HiRes::time()];
my $runningrecordcount=0;
###################################################

#go through each file  
foreach my $filetoclean (@filestoclean) {

#get file name portion of path
(my $volume, my $directories, my $filename) = File::Spec->splitpath( $filetoclean);

##### File handling initialization ######
#prompt for updated file
my $infh = new IO::File;

$infh->open("<$filetoclean"); 
print ("Opened $filetoclean\n");

my $tempfile = File::Temp::tempfile() or die "can not open temporary file\n";

my $exportfile = $cleaned_dir.$filename;
open(OUT, ">$exportfile")  or die "can not open out $exportfile\n";


#clean up trailing and leading spaces
#read original file lines into an array
my @filelines = $infh->getlines;

for (my $lineno = 0; $lineno <= $#filelines-1; $lineno++) {
my $firstline = $filelines[$lineno];
chomp $firstline;
my $secondline = $filelines[$lineno+1];
chomp $secondline;

#remove trailing spaces
$firstline =~ s/\s+$//;
$secondline =~ s/\s+$//;

#remove leading spaces, asterisks, (A), and (C) before tagno
$firstline =~ s/^[*\s\(\)AC]*(\d{3})/$1/;
$secondline =~ s/^[*\s\(\)AC]*(\d{3})/$1/;
#remove unnecessary breaks in fields
if ($secondline =~ /^\s+/) {
#then it is part of firstline
$secondline =~ s/^\s+//;
$firstline .= "  $secondline";
$lineno++;
}
print $tempfile ("$firstline\n");

} #for lines in orig. input file
my $lastline = $filelines[$#filelines];
print $tempfile ("$lastline\n");


$infh->close;

#go to start of $tempfile
seek $tempfile, 0, 0;

#################################################
######### Start condensing to cancelled #########
#################################################

#reset record separator to two returns/line feeds in a row
use constant END_OF_RECORD	    => "\n\n";
local $/ = END_OF_RECORD;

my $cancelcount = 0;
#### Start while loop through records/headings in file #####
while (my $record = <$tempfile>) {
#put each line into a separate array slot
my @reclines = split ("\n", $record);

my @newreclines;
#discard non-1xx lines and push 1xx onto new record line array
foreach my $recline (@reclines) {
unless ($recline =~ /^1\d\d\s/) {$recline = '';
}
else {push @newreclines, $recline;}
}
#add record separator (new line character) to new record
push @newreclines, "\n";

### For testing??? ###
#my $newrec = join ("\n", @newreclines);
#print OUT "$newreclines[0]\n";
######################

#format of each element of @newreclines of interest:
#(1xx)\s\s(HDG)\s\s+CANCEL

if ($newreclines[0] =~ /^(1\d\d)\s\s([-.,':?\w\(\)\s]+)\s\s+CANCEL/) {
my $tagno = $1;
my $oldhdg = $2;
$oldhdg =~ s/\s+$//;
#verify that cancelled hdg has been replaced by new 1xx on 2nd line
if ($newreclines[1] =~ /^(1\d\d)\s\s([-.,':?\w\(\)\s]+)\s\s+/){
my $newhdg = $2;
$newhdg =~ s/\s+$//;
print OUT "$tagno\t$oldhdg\t$newhdg\n";
$cancelcount++;
}
#if replacement heading isn't next, print second line
else {print "$newreclines[0]\t$newreclines[1] in $filename\n";}
} #if hdg was cancelled
###################################################
### add to count for user notification ###
$runningrecordcount++;
MARC::BBMARC::counting_print ($runningrecordcount);
###################################################
} #while

close $tempfile;
close OUT;
print "\n";
print "$runningrecordcount records parsed\n$cancelcount headings cancelled in $filename\n";
} # foreach filetoclean
##########################
### Main program done.  ##
### Report elapsed time.##
##########################

my $elapsed = tv_interval ($t0);
my $calcelapsed = tv_interval ($t1);
print sprintf ("%.4f %s\n", "$elapsed", "seconds from execution\n");
print sprintf ("%.4f %s\n", "$calcelapsed", "seconds to calculate\n");
my $endingtime = MARC::BBMARC::startstop_time();
print "Started at $startingtime\nEnded at $endingtime";

print "Press Enter to continue";
<>;

#####################
### END OF PROGRAM ##
#####################

=head1 LICENSE

This code may be distributed under the same terms as Perl itself. 

Please note that this code is not a product of or supported by the 
employers of the various contributors to the code.

=head1 AUTHOR

Bryan Baldus
eija [at] inwave [dot] com

Copyright (c) 2003-2004

=cut